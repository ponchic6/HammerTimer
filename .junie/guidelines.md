# Руководство по структуре кода Entitas (Unity)

Это практическое руководство по организации кода в Unity-проекте на Entitas (Jenny) ECS. Оно стандартизирует структуру фич, систем, компонентов и связанных активов, чтобы проект оставался масштабируемым и последовательным. Руководство проект-независимо и подходит для любых Unity/Entitas проектов.

## Что такое ECS

Entity-Component-System — архитектурный паттерн, созданный специально для разработки игр, отлично подходящий для описания динамического виртуального мира. ECS возводит в абсолют принцип Composition Over Inheritance и может являться примером Data Oriented Design.

**Entity** — сущность, максимально абстрактный объект. Условный контейнер для свойств, определяющих чем будет являться эта сущность. Представляется в виде идентификатора для доступа к данным.

**Component** — компонент, свойство с данными объекта. Компоненты должны содержать исключительно чистые данные, без логики.

**System** — система, логика обработки данных. Системы не должны содержать данных, только логику обработки.

ECS строго отделяет данные от логики. Поведение объекта определяется не интерфейсами, а присвоенными данными + существующей отдельно логикой обработки. В ECS данные определяют всё — это главное свойство паттерна.

## Преимущества ECS

- **Слабая связность кода** — легкий рефакторинг и расширение без поломки старого кода
- **Идеальная модульность** — логика отвязана от источника данных, легко тестируется
- **Комбинаторика свойств** — любое свойство можно добавить любой сущности без геморроя
- **Простота соблюдения Single Responsibility** — каждая система выполняет конкретную задачу
- **Наглядный профайлинг** — сразу видно какая система сколько времени отнимает
- **Производительность** — кэш-френдли код при правильной реализации фреймворка

Цели:
- Понятная, предсказуемая структура папок и пространств имён
- Разделение по доменам (фичам) с локальной агрегацией систем
- Тонкие компоненты (только данные), поведение — в системах; сервисы и утилиты — отдельно
- Генерируемый код хранится в Generated и не редактируется вручную


1. Структура решений и папок
- Assets/Code/
  - Gameplay/ — корневая агрегация геймплея
    - MainFeature.cs
    - <Domain>/ (Soldiers, Towers, UI и т.д.)
      - Systems/
      - Services/
      - Registrars/
      - View/
  - Generated/ — Jenny сгенерированный код; не трогать
  - Infrastructure/ — кросс-фичевая логика: раннер, DI, view-linking, destroy, сервисы
    - View/
    - Destroy/
    - Systems/
    - Services/
    - StaticData/

Имена пространств имён зеркалируют папки: Code.Gameplay.Soldiers.Systems.

2. Компоненты
- Расположение: Assets/Code/Gameplay/<FeatureName>/
- Все компоненты фичи в одном файле <FeatureName>Components.cs без подкаталога Components и без разбиения на файлы по одному классу.
- Тип: public class XxxComponent : IComponent
- Только данные (без логики)
- Именование:
    - Состояние: <Name>Component (HealthComponent)
    - Маркер: <Name> (без данных), без суффикса Tag (Player, Alive)
    - Ссылки на Unity-объекты: <Name>Link (AnimatorLink и т.п.)
- Поля: публичные
- Атрибуты: использовать только [Game]

3. Агрегация фич (Feature/Installer)
- Место: Assets/Code/Gameplay/<FeatureName>/Systems/<FeatureName>Feature.cs
- Собирает системы с упорядочиванием: Setup → Execute → Reactive → Cleanup
- Порядок внутри группы — по зависимостям: производители раньше потребителей

4. Системы
- Интерфейсы: IInitializeSystem, IExecuteSystem, ICleanupSystem, IReactiveSystem
- Конструктор: public XxxSystem(Contexts contexts) или со специфичными зависимостями
  - Обязательное правило и шаблон кэширования контекстов в поля:
    - Если система использует Contexts.sharedInstance и GameContext, кэшируйте GameContext в приватные readonly поля и используйте в методах.
    - Не использовать var. Всегда использовать явные типы в остальном коде.
  - Имена рекомендуемых полей: private readonly GameContext _gameContext.
- Зависимости (сервисы) принимать через параметры конструктора; создавать через фабрику/инсталлер.
- Именование систем: Не использовать Entity/Entities в названии.
- Ответственность: узкая, тестопригодная; избегать не относящихся компонентов.
- Контекст: предпочитать один контекст на систему.
- Группа в системах: приватное поле-группа именовать строго _entities.
- Не выполнять null-check обязательных сущностей/компонентов в Execute/Reactive: наличие должно гарантироваться setup-системами (Ensure/Spawn/Initialize). Система работает так, как будто сущность точно есть; в противном случае — это ошибка конфигурации, а не ветвление в рантайме.

Пример Reactive:
public class DamageTakenReactiveSystem : ReactiveSystem<GameEntity> {
    public DamageTakenReactiveSystem(Contexts contexts) : base(contexts.game) {}
    protected override ICollector<GameEntity> GetTrigger(IContext<GameEntity> context)
        => context.CreateCollector(GameMatcher.DamageApplied.Added());
    protected override bool Filter(GameEntity e) => e.hasHealth && e.hasDamageApplied;
    protected override void Execute(List<GameEntity> entities) {
        foreach (GameEntity entity in entities) { entity.ReplaceHealth(entity.health.value - entity.damageApplied.value); }
    }
}

5. View и интеграция с Unity
- MonoBehaviour — только связи и проброс событий в компоненты, без бизнес-логики
- Паттерн Link: компонент Link с ссылкой на MonoBehaviour, который хранит entityId
- Ни в коем случае не получать доступ к EntityBehaviour из систем ECS. Системы не создают/не читают MonoBehaviour и не вызывают GetComponent/SetEntity; создание и связывание вьюхи выполняют инфраструктурные системы (ViewPath/ViewPrefab + EntityViewFactory).
- Создание префабов: используйте специализированный инструмент создания префабов проекта (prefab creator/утилиту) вместо unity_execute. Это обеспечивает детерминированность, корректный импорт ассетов и воспроизводимость; unity_execute предназначен для одноразовых редакторных операций и не должен использоваться для управления жизненным циклом ассетов.

5.1 EntityComponentRegistrar
- Место: Assets/Code/Infrastructure/View/Registrars/
- Наследник Code.Infrastructure.View.EntityComponentRegistrar
- Строгая форма:
  - public class XxxRegistrar : EntityComponentRegistrar
  - Без сериализуемых полей, без Reset, без условий, без Replace
  - RegisterComponent: только Add… с источником из MonoBehaviour
  - UnregisterComponent: только Remove…
  - Без null-check'ов и кешей
- Жизненный цикл: EntityBehaviour вызывает Register/Unregister на SetEntity/ReleaseEntity
- Именование: TransformRegistrar, AnimatorRegistrar и т.п.

6. Сервисы
- Интерфейсы в фиче/ядре, реализации — рядом или в под-платформах
- Внедрение через инсталлер/фичу

7. События
- Предпочитать компоненты-события и реактивные системы

8. Контексты и области
- В проекте использовать только контекст Game
- Компоненты помечать только [Game]

9. Именование, файлы, стиль
- Один публичный тип на файл; имя файла == имя типа
- PascalCase для типов, camelCase для полей, UPPER_SNAKE для констант
- До 300 строк на файл, без комментариев в коде, без sealed классов
- Избегать магических чисел — выносить в ScriptableObject или константы
- Не использовать сокращения и однобуквенные имена
- Имя группы в системах: _entities
- Всегда использовать явные типы, не использовать var
- Пустых .cs файлов быть не должно

10. Generated Code
- Не трогать в Assets/Code/Generated
- Добавляете компонент — запускаете Jenny
- Всегда в конце работы (после правок компонентов/систем/фич) запускайте генерацию кода Jenny, чтобы ничего не упустить. Команда для этого проекта: dotnet Jenny\Jenny.Generator.Cli.dll gen Jenny.properties -v (или запустите Jenny-Auto-Import.bat).

11. Тестирование
- NUnit тесты под Assets/Tests/Editor
- Системы тестировать как чистый C#, без Unity API

12. Пример каркаса фичи (Units)
- Components, Systems (Setup/Execute/Reactive/Cleanup), Views, Services, FeatureInstaller

13. Системы — буферы и кэширование контекстов
- Буферы (List<GameEntity>) использовать ТОЛЬКО когда:
  - Внутри итерации меняете компоненты, влияющие на состав группы
- Не использовать буфер, когда читаете состояние или меняете компоненты, которые не влияют на матчёр — итерируйтесь foreach по группе
- Кэширование Contexts/GameContext:
  - Если система использует Contexts.sharedInstance и GameContext — кэшируйте их в полях (_contexts, _gameContext)
  - ВАЖНО: если контекст уже закэширован в поля, НЕ оставляйте в конструкторе такие же локальные переменные. Используйте прямое присваивание в поля:
    _contexts = Contexts.sharedInstance;
    _gameContext = _contexts.game;
  - Поля использовать в Initialize/Execute/Cleanup
- Вложенные foreach циклы:
  - Если есть два foreach цикла и их логически можно расположить один в другом (когда второй цикл зависит от результата первого или работает с данными из первого), то всегда располагайте их вложенно
  - Это улучшает читаемость кода и показывает логическую связь между итерациями

14. Проверочные списки
- Компонент: имя, [Game], файл фичи, Jenny
- Система: фаза, имя, добавить в Feature
- View: только связь с Unity, Link + компонент
- Сервис: интерфейс, реализация, инъекция

15. Приложение A — стартовая структура проекта
- Gameplay/MainFeature — агрегатор инфраструктурных фич (ViewFeature, DestroyFeature)
- Infrastructure: EcsRunner, Installers, SystemFactory, View helpers, Destroy, Services, StaticData

## Хорошие практики ECS

### Тегование сущностей маркерными компонентами
Компонент-маркер — это компонент без полей, выполняющий роль маркировки сущности. Воспринимайте его как boolean-флаг: он либо есть (true), либо его нет (false). Используйте для фильтрации и идентификации сущностей определенного типа.

### Минимизировать места изменения компонента
Чем меньше мест, где меняется компонент, тем лучше. Создавайте одну систему, ответственную за изменение конкретного типа данных. Например, вместо изменения HealthComponent в каждой системе с уроном, создайте одну DamageSystem.

### Вынос повторяющейся логики в StaticUtils/Extensions
Создавайте статические утилиты для повторяющейся вспомогательной логики, связанной с компонентами. Это сохраняет принципы ECS, вынося логику за пределы компонентов.

### Группировка систем по времени выполнения
Группируйте системы по моменту выполнения в кадре:
- Input системы — сбор пользовательского ввода
- Game Logic системы — основная игровая логика
- Render/Cleanup системы — отрисовка и очистка

## Типичные ошибки новичков

### ❌ Наследование компонентов и интерфейсы
НЕ создавайте иерархии компонентов и интерфейсы для них. Это нарушает принципы ECS и создает ненужные ограничения. Используйте ECS-абстракцию через отдельные компоненты.

### ❌ Неумение в ECS-абстракцию
Общие данные выносите в отдельные компоненты вместо наследования. Создавайте "наследника" добавлением нового компонента и фильтрацией сущностей с BaseComponent и InheritorComponent.

### ❌ Включение/отключение систем для изменения логики
НЕ отключайте системы для изменения поведения. Используйте компоненты-маркеры для контроля работы логики. Добавляйте в начало системы проверку: `if (entities.Length < 1) return;`

### ❌ Возведение ECS в абсолют
НЕ переносите всё на ECS принудительно. Используйте обычные ООП-классы для структур данных, UI, сервисов и вспомогательной логики, где это уместно.

### ❌ Дословное перекладывание кода на ECS
НЕ переносите существующий код один в один. Переписывайте логику с нуля, применяя принципы ECS.

### ❌ Использование Delegates/Callbacks в системах
Избегайте захвата логики из систем в компоненты через делегаты. Это нарушает конвейер обработки данных. Используйте отложенную реактивность через компоненты-события.

### ❌ Разбивка файлов по типам
НЕ группируйте файлы по типам (Components/, Systems/). Разбивайте по фичам — всё, что относится к определенной функциональности, должно лежать в одной папке.

